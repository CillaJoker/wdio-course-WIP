{
  "script": "\n            var __defProp = Object.defineProperty;var __name = function (target, value) { return __defProp(target, 'name', { value: value, configurable: true }); };var __globalThis = (typeof globalThis === 'object' && globalThis) || (typeof window === 'object' && window);__globalThis.__name = __name;\n            return (function isElementDisplayed(element) {\n  function nodeIsElement(node) {\n    if (!node) {\n      return false;\n    }\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        return true;\n      default:\n        return false;\n    }\n  }\n  function parentElementForElement(element2) {\n    if (!element2) {\n      return null;\n    }\n    return enclosingNodeOrSelfMatchingPredicate(element2.parentNode, nodeIsElement);\n  }\n  function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n    for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n      if (predicate(node)) {\n        return node;\n      }\n    }\n    return null;\n  }\n  function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n    for (let element2 = targetElement; element2 && element2 !== targetElement.ownerDocument; element2 = parentElementForElement(element2)) {\n      if (predicate(element2)) {\n        return element2;\n      }\n    }\n    return null;\n  }\n  function cascadedStylePropertyForElement(element2, property) {\n    if (!element2 || !property) {\n      return null;\n    }\n    if (\"ShadowRoot\" in window && element2 instanceof window.ShadowRoot) {\n      element2 = element2.host;\n    }\n    const computedStyle = window.getComputedStyle(element2);\n    const computedStyleProperty = computedStyle.getPropertyValue(property);\n    if (computedStyleProperty && computedStyleProperty !== \"inherit\") {\n      return computedStyleProperty;\n    }\n    const parentElement = parentElementForElement(element2);\n    return cascadedStylePropertyForElement(parentElement, property);\n  }\n  function elementHasBoundingBox(element2) {\n    const boundingBox = element2.getBoundingClientRect();\n    return boundingBox.width > 0 && boundingBox.height > 0;\n  }\n  function elementSubtreeHasNonZeroDimensions(element2) {\n    if (elementHasBoundingBox(element2)) {\n      return true;\n    }\n    const boundingBox = element2.getBoundingClientRect();\n    if (element2.tagName.toUpperCase() === \"PATH\" && boundingBox.width + boundingBox.height > 0) {\n      const strokeWidth = cascadedStylePropertyForElement(element2, \"stroke-width\");\n      return !!strokeWidth && parseInt(strokeWidth, 10) > 0;\n    }\n    const cascadedOverflow = cascadedStylePropertyForElement(element2, \"overflow\");\n    if (cascadedOverflow === \"hidden\") {\n      return false;\n    }\n    return [].some.call(element2.childNodes, function(childNode) {\n      if (childNode.nodeType === Node.TEXT_NODE) {\n        return true;\n      }\n      if (nodeIsElement(childNode)) {\n        return elementSubtreeHasNonZeroDimensions(childNode);\n      }\n      return false;\n    });\n  }\n  function elementOverflowsContainer(element2) {\n    const cascadedOverflow = cascadedStylePropertyForElement(element2, \"overflow\");\n    if (cascadedOverflow !== \"hidden\") {\n      return false;\n    }\n    return true;\n  }\n  function isElementSubtreeHiddenByOverflow(element2) {\n    if (!element2) {\n      return false;\n    }\n    if (!elementOverflowsContainer(element2)) {\n      return false;\n    }\n    if (!element2.childNodes.length) {\n      return false;\n    }\n    return [].every.call(element2.childNodes, function(childNode) {\n      if (childNode.nodeType === Node.TEXT_NODE) {\n        return false;\n      }\n      if (!nodeIsElement(childNode)) {\n        return true;\n      }\n      if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n        return true;\n      }\n      return isElementSubtreeHiddenByOverflow(childNode);\n    });\n  }\n  function isElementInsideShadowRoot(element2) {\n    if (!element2) {\n      return false;\n    }\n    if (element2.parentNode && element2.parentNode.host) {\n      return true;\n    }\n    return isElementInsideShadowRoot(element2.parentNode);\n  }\n  if (!isElementInsideShadowRoot(element) && // IE doesn't support document.contains, therefor check before using\n  (typeof document.contains === \"function\" ? !document.contains(element) : !document.body.contains(element))) {\n    return false;\n  }\n  switch (element.tagName.toUpperCase()) {\n    case \"BODY\":\n      return true;\n    case \"SCRIPT\":\n    case \"NOSCRIPT\":\n      return false;\n    case \"OPTGROUP\":\n    case \"OPTION\": {\n      const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function(e) {\n        return e.tagName.toUpperCase() === \"SELECT\";\n      });\n      return isElementDisplayed(enclosingSelectElement);\n    }\n    case \"INPUT\":\n      if (element.type === \"hidden\") {\n        return false;\n      }\n      break;\n    // case 'MAP':\n    // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n    default:\n      break;\n  }\n  if (cascadedStylePropertyForElement(element, \"visibility\") !== \"visible\") {\n    return false;\n  }\n  const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function(e) {\n    return Number(cascadedStylePropertyForElement(e, \"opacity\")) === 0;\n  });\n  const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function(e) {\n    return cascadedStylePropertyForElement(e, \"display\") === \"none\";\n  });\n  if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n    return false;\n  }\n  if (!elementSubtreeHasNonZeroDimensions(element)) {\n    return false;\n  }\n  if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n    return false;\n  }\n  return true;\n}).apply(null, arguments)\n        ",
  "args": [
    {
      "element-6066-11e4-a52e-4f735466cecf": "f.CC055F09672AF2A48C2ED41F8651FFF4.d.2C1EFE9087216A4555FF1AEB1D949969.e.59",
      "ELEMENT": "f.CC055F09672AF2A48C2ED41F8651FFF4.d.2C1EFE9087216A4555FF1AEB1D949969.e.59"
    }
  ]
}